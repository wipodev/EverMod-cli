# ğŸ§  EverMod CLI â€” Technical Documentation

**Author:** WipoDev
**Version:** 1.0
**Last updated:** 2025-11-03

---

## ğŸ“˜ Overview

**EverMod CLI** is the command-line companion to the [EverMod Framework](https://github.com/wipodev/EverMod).
It provides an automated environment for creating, maintaining, documenting, and publishing Forge modding projects within a unified workspace system.

This document is intended for **technical developers and maintainers**, not end users. It covers the internal architecture, command flow, packaging system, and build automation of the CLI.

---

## ğŸ§± Project Structure

```
evermod-cli/
â”œâ”€â”€ build.py                     # Build automation (PyInstaller + Inno Setup)
â”œâ”€â”€ evermod.spec                 # PyInstaller specification
â”œâ”€â”€ src/evermod/
â”‚   â”œâ”€â”€ main.py                  # CLI entrypoint
â”‚   â”œâ”€â”€ auth/                    # Internal RSA key system
â”‚   â”œâ”€â”€ commands/                # CLI subcommands
â”‚   â””â”€â”€ utils/                   # Helper utilities
â”œâ”€â”€ docs/                        # Documentation folder
â”œâ”€â”€ manifest.json                # CLI metadata
â”œâ”€â”€ setup.iss                    # Inno Setup installer configuration
â””â”€â”€ requirements.txt             # Python dependencies
```

---

## âš™ï¸ Core Architecture

### ğŸ§© Main Entry Point (`main.py`)

- Uses `argparse` to define CLI syntax.
- Registers subcommands dynamically via `subparsers`.
- Hides the internal `release` command from the public help menu.
- Routes execution to respective command handlers:

```python
match args.command:
    case "create": create.run()
    case "evermix": evermix.run(args.target)
    case "add": add.run(args.user, args.name, args.target)
    case "update": update.run(args.force, args.silent)
    case "refresh": gradle_tools.refresh_environment()
    case "release": release.run(args.release_tag, args.publish, args.auto, args.target)
```

The CLI operates in **workspace mode** when executed inside a Gradle multi-project setup (detected via `settings.gradle`), or in **standalone mode** when used in an isolated mod folder.

---

## ğŸ§© Command Modules

Each command resides in `src/evermod/commands/` and exposes a `run()` method.
They are designed to be atomic, self-contained, and composable.

### 1. `create.py` â€” Mod Creation Wizard

- Interactive wizard that builds a new Forge mod from EverMod MDK templates.
- Uses **Jinja2** templating for `.java`, `.gradle`, and `.properties` files.
- Detects current workspace automatically.
- Registers the new mod in `settings.gradle` if applicable.
- Generates:

  - Source directories (`src/main/java`, `resources`)
  - Gradle wrapper (if standalone)
  - Pre-filled metadata files (`mods.toml`, `pack.mcmeta`, `LICENSE.txt`)

**Key functions:**

- `_sanitize_string()` â†’ ensures valid modid naming.
- `_sanitize_package()` â†’ formats Java packages.
- `refresh_environment()` â†’ triggers Gradle reindexing after creation.

---

### 2. `add.py` â€” Add Git Submodule

- Automates `git submodule add https://github.com/<user>/<mod>.git`.
- Automatically registers the submodule in `settings.gradle`.
- Refreshes Gradle dependencies upon completion.

**Workflow:**

1. Clones repository into `/mods/<mod>`.
2. Appends an `include("mods:<mod>")` line to `settings.gradle`.
3. Calls `gradle_tools.refresh_environment()`.

---

### 3. `evermix.py` â€” Source Consolidation System

- Gathers project source code into a single XML (`<project>`) for AI-based analysis or documentation.
- Excludes binary and build artifacts via `.gitignore` + `evermix.config.json`.
- Includes token counting and binary detection for optimization.

**Output example:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project>
  <context>Generated by EverMix for analysis and documentation.</context>
  <structure>
    <path>src/main/java/.../MainMod.java</path>
    <path type="binary">assets/icon.ico</path>
  </structure>
  <file name="MainMod.java"> ... </file>
</project>
```

---

### 4. `update.py` â€” Template Updater

- Fetches the latest **EverMod Templates** from GitHub.
- Compares versions using the `packaging` library.
- Clones new templates to `~/.evermod/templates`.
- Updates local `version.json` manifest.
- Supports flags:

  - `--force` â†’ reinstall even if same version.
  - `--silent` â†’ suppress interaction (used by installer).

---

### 5. `version.py` â€” Version Inspector

- Displays the version of:

  - The CLI (`manifest.json`)
  - Compatible framework version
  - Installed template version (from global path)

Example output:

```
ğŸ§© EverMod CLI Information
----------------------------
CLI Version:           v1.0.0
Compatible Framework:  v1.0.0
Installed Templates:   v1.2.1
Templates Released:    2025-11-03
Global Path:           C:\Users\<user>\.evermod
```

---

### 6. `release.py` â€” Internal Release Builder

> **Restricted command.** Requires valid internal RSA authorization.

Performs full framework packaging and release publication.
See `docs/EverMod_Release_System.md` for complete details.

#### Summary:

1. Authenticates via `require_internal_auth()`.
2. Compresses `framework/evermod-*` modules â†’ individual ZIPs.
3. Builds `evermod-framework.zip` (full workspace package).
4. Generates and signs `versions.json`.
5. Optionally publishes to GitHub (`publish_release()`).
6. Tags main branch (`create_main_tag()`).

---

## ğŸ” Security and Authorization System

### RSA Key Architecture

| Component       | Path                                       | Description                                         |
| --------------- | ------------------------------------------ | --------------------------------------------------- |
| **Public key**  | `src/evermod/auth/keys/evermod_public.pem` | Distributed inside the CLI binary for verification. |
| **Private key** | `~/.evermod/keys/private.pem`              | Local-only key used to sign internal releases.      |

The system signs and verifies messages and files using **RSA + SHA256**.

#### Example:

```python
from evermod.auth.security import sign_file, verify_file_signature

sig_path = sign_file(Path('versions.json'))
verify_file_signature(Path('versions.json'), sig_path)
```

**Protection logic:**

- Commands like `release` call `require_internal_auth()`.
- Missing or invalid keys immediately abort execution.
- Each `versions.json` is signed to ensure integrity of releases.

---

## ğŸ§° Utilities

### `gradle_tools.py`

- Refreshes Gradle dependencies cross-platform.
- Runs either `gradlew.bat` or `./gradlew`.
- Prints VS Code tips to reindex Java environment.

### `paths.py`

- Provides directory abstractions:

  - `get_global_dir()` â†’ `~/.evermod`
  - `get_templates_dir()` â†’ `~/.evermod/templates`
  - `get_versions_file()` â†’ `versions.json`
  - `get_manifest_path()` â†’ Detects manifest whether compiled or source.

### `publisher.py`

Handles Git-based publishing for releases:

- Ensures `releases` branch exists remotely.
- Pushes versioned artifacts.
- Updates `latest/` alias for stable builds.
- Creates and signs Git tags (GPG if configured).

---

## ğŸ§© Build System (`build.py`)

Automates the creation of standalone executables and Windows installers.

### ğŸ§± Build Steps

1. **Version Syncing** â€” Updates `setup.iss` and `pyproject.toml` with manifest version.
2. **Cleaning** â€” Removes old build and dist folders.
3. **PyInstaller** â€” Builds `evermod.exe` using `evermod.spec`.
4. **Inno Setup** â€” Generates `EverMod-Setup.exe`.
5. **Optional Key Generation** â€” Produces RSA key pair before build.

### ğŸ”‘ Key Generation

```bash
python build.py --keys
```

Creates:

```
~/.evermod/keys/private.pem
src/evermod/auth/keys/evermod_public.pem
```

---

## ğŸ§® Dependencies

| Package          | Version | Purpose                                 |
| ---------------- | ------- | --------------------------------------- |
| **Jinja2**       | 3.1.6   | Template rendering for mod generation.  |
| **packaging**    | 25.0    | Version comparison and parsing.         |
| **cryptography** | 46.0.3  | RSA signing and file verification.      |
| **pathspec**     | 0.12.1  | .gitignore pattern parsing for EverMix. |

All dependencies are Python-native and bundled by PyInstaller during compilation.

---

## ğŸ§­ Execution Flow Summary

```
User â†’ evermod create
      â†“
  main.py parses args
      â†“
  commands.create.run()
      â†“
  utils.paths / gradle_tools / Jinja2 templates
```

---

## ğŸ§© Extending EverMod CLI

To add a new command:

1. Create a new file in `src/evermod/commands/` (e.g. `deploy.py`).
2. Define `run()` function.
3. Register it in `main.py` under `subparsers`.
4. Optionally, use existing utilities for consistency.

Ensure new features respect the following:

- **Non-destructive defaults** (never overwrite without confirmation).
- **Cross-platform compatibility**.
- **Silent/interactive modes** where applicable.

---

## âœ… Best Practices

- Always run builds from a clean Git workspace.
- Keep `manifest.json` version synced before packaging.
- Never distribute private RSA keys.
- Run `evermod update` regularly to sync templates.
- Use `release --auto` only in CI/CD pipelines.

---

## ğŸª„ Future Enhancements

- CI/CD integration with GitHub Actions.
- Optional analytics for command usage.
- Global configuration file for defaults.
- Plugin loader for custom subcommands.
- Improved multi-platform installer support.

---

## âš™ï¸ License

Licensed under the **Apache License 2.0**.
Â© 2025 WipoDev â€” All rights reserved.
